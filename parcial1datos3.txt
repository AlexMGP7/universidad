//Este ejercicio dice que se compruebe si "una cifra es capicua", entonces, una cifra cualquiera
//puede ser "1", por lo tanto, el ejercicioo esta mal redactado, y se quiere referir a
//comprobar un conjunto de cifras (ej:"1234"), o tambien que sea un trampa y en realidad el Metodo
//simplemente es leer una cifra y decir que es capicua porque siempre lo será
//En este caso asumire que se quiere referir a un conjunto de cifras

1.Metodo Capicua (entero cifras) -> boolean
    CONSTANTES
    VARIABLES
    boolean Comprobar
    entero aux
    TDA_Pila P

    INICIO
        Mientras cifras > 9
            P.Push(P, cifras % 10)
            cifras <-  cifras / 10
        FinMientras

        P.Push(P,cifras)
        Comprobar <- Verdadero

        Mientras (Comprobar = Verdadero)
            Si (cifras % 10) = P.Top
                P.Pop(P,Top)
                cifras <- cifras / 10
            Sino
                Comprobar = Falso
        FinMientras

        Capicua <- Comprobar

FinMetodo

2.Metodo Ackerman(entero m, entero n)
//A(0,n) = n+1
//A(m+1,0) = A(m,1)
//A(m+1,n+1) = A(m,A(m+1,n))

    CONSTANTES
    VARIABLES

    TDA_Pila P

    INICIO

    P.Push(P,m)
    Mientras no(P.Vacia) Hacer
        m <- P.Cima(P)
        P.Pop(P)
        Si m=0 entonces
            n <- n+1
        Sino
            Si  n=0 entonces
                n <- 1
                P.Push(P,m-1)
        Sino
                n <- n-1
                P.Push(P,m-1)
                P.Push(P,m)
    Ackerman <- n
FinMetodo

3.TDA_Multi_Pilas = Clase de
    // Atributos
    entero MAX_PILA
    entero Top1 <- 0
    entero Top2 <- MAX_PILA
    arreglo multi[MAX_PILA]

    // Metodos
    Metodo Llena -> boolean
    INICIO
        Si multi[Top1+1] = multi[Top2]
            Llena <- Verdadero
        Sino
            Llena <- Falso
        Finsi
    FinMetodo

    Metodo Cima1 (TDA_Multi_Pilas multi[])
    INICIO
        Si no (Vacia(P)) entonces
            Cima1 <- P.multi[Top1]
        Sino
            Escribir ("Pila vacia")
        Finsi
    FinMetodo

    Metodo Cima2(TDA_Multi_Pilas P[])
    INICIO
        Si no (Vacia(P)) entonces
            Cima2 <- P.s[Top2]
        Sino
            Escribir ("Pila vacia")
        Finsi
    FinMetodo

    Metodo Vacia (tda_pila p) -> boolean
    INICIO
        Si (Top1=0 ^ Top2=Tamaño_Arr) entonces
            Vacia <- Verdadero
        Sino
            Vacia <- Falso
        Finsi
    FinMetodo

    Metodo Push1(TDA_Multi_Pilas, entero E)
        INICIO
        Si no(Llena (P.multi[])) entonces //si no está Llena
            Top1<- Top1+1
            P.M[Top1]<- E
        Sino
            Escribir ("Pila llena")
        Finsi
    FinMetodo

    Metodo Pop1(TDA_Multi_Pilas)
        INICIO
        Si no (Vacia (p.multi[])) entonces
            Top1<- Top1-1
        Sino
            Escribir ("Pila llena")
        Finsi
        FinMetodo

    Metodo Push2(TDA_Multi_Pilas, entero E)
        INICIO
        Si no (Llena (P.multi[])) entonces //si no está Llena
            Top2<- Top2-1
            P.M[Top1]<- E
        Sino
            Escribir ("Pila llena")
        Finsi
    FinMetodo

    Metodo Pop2(TDA_Multi_Pilas)
        INICIO
        Si no (Vacia (p.multi[])) entonces
            Top2<- Top2+1
        Sino
            Escribir ("Pila llena")
        Finsi
    FinMetodo
FinTDA

4.TDA_CM = Clase de
    // Atributos del nodo
    Caracter clase_sos
    ˆTDA_CM sig,ant
FinClase

Cola_Med = Clase de
    ˆTDA_CM Frente // Misma salida
    ˆTDA_CM E_Ple,E_Nob // Diferentes entradas con prioridad a la nobleza
    ˆTDA_CM CM // Cola multiple contenedor
    // Metodos
    Metodo Meter (Cola_Med X,ˆTDA_CM E,Caracter c)
    VARIABLES
    INICIO
        Si (Vacia(X)) entonces
            Caso c sea:
            'N':X.E_Nob <- E
                X.Frente <- E
            'P':X.E_Ple <- E
                X.Frente <- E
            FinCaso
            X.Insertar_Inicio(X,E)
        Sino
            Caso c sea:
            'N':Si (Frente.clase_sos = 'P') entonces
                    X.E_Nob <- E
                    X.Frente <- E
                Sino
                    X.E_Nob <- E
                FinSi
            'P':X.E_Ple <- E
            FinCaso
            X.Insertar_Fin_Seg(X,E)
        FinSi
    FinMetodo
    Metodo Atender (Cola_Med X)
    Variables:
        ˆTDA_CM Aux
    Inicio:
        Si NO(Vacia(X)) entonces
            Caso Frente.clase_sos
     sea:
            'N':Si NO(Frente = Nulo) entonces
                    Aux <- Frente
                    Si (Frente = E_Nob) entonces
                        Frente <- Nulo
                    Sino
                        Frente <- Frente.ˆsig
                    FinSi
                Sino
                    Escribir "No hay ninguna persona a la cual atender"
                FinSi
            'P':Si (E_Nob = Nulo) entonces
                    Aux <- Frente
                    Si (Frente = E_Ple) entonces
                        Frente <- Nulo
                    Sino
                        Frente <- Frente.ˆsig
                    FinSi
                 Sino
                    Escribir "No es posible eliminarse, hay nobles sin atender"
                 FinSi
            FinCaso
        Sino
            Escribir "No hay personas para atender"
        FinSi
    FinMetodo
FinClase
